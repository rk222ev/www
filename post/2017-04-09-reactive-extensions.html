<!doctype html><html><head><meta charset="UTF-8" /><meta content="ie=edge" http-equiv="x-ua-compatible" /><meta content="" name="description" /><meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport" /><title>rpkn.se - Reactive extension - A quick primer</title><link href="https://cdn.rawgit.com/dreampulse/computer-modern-web-font/master/fonts.css" rel="stylesheet" type="text/css" /><link href="/default.css" rel="stylesheet" type="text/css" /></head><body><div id="wrap"><div id="header"><h1><a href="">rpkn.se</a></h1><div id="navigation"><ul><li><a href="/index.html">Home</a></li><li><a href="/about.html">About</a></li></ul></div></div><div class="content"></div><h1>Reactive extension - A quick primer</h1><div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgddc993a">Background</a></li>
<li><a href="#org4cd831f">What is it all about?</a></li>
<li><a href="#orgfbe7191">Creating Observables</a></li>
<li><a href="#orgefa87ef">Intro to marble diagrams</a></li>
<li><a href="#org0000b28">Some basic operators</a>
<ul>
<li><a href="#orgf6f893b">FlatMap</a></li>
<li><a href="#org87cd74e">ConcatMap</a></li>
<li><a href="#org327645d">Reduce</a></li>
</ul>
</li>
<li><a href="#orgc33395f">Combining Observables</a>
<ul>
<li><a href="#org0add57f">Merge</a></li>
<li><a href="#orgf91fce1">Zip</a></li>
</ul>
</li>
<li><a href="#orga2fe676">Final thoughts</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgddc993a" class="outline-2">
<h2 id="orgddc993a">Background</h2>
<div class="outline-text-2" id="text-orgddc993a">
<p>
These notes on Reactive extensions are something I've done as a way for me to learn more about
Reactive extension. I'm new to both Reactive extension and Java so this is an effort for me
to learn and hopefully create something that can be used by others trying to get started
with Reactive extensions.
</p>

<p>
So with that in mind, be aware that errors most certainly are present.
</p>
</div>
</div>

<div id="outline-container-org4cd831f" class="outline-2">
<h2 id="org4cd831f">What is it all about?</h2>
<div class="outline-text-2" id="text-org4cd831f">
<p>
Think of Observables as a sequence of values emitted over time.
Much like a normal sequential data structure, but instead of pulling data from the sequence,
the Observable pushes data to listeners subscribed to the sequence
using an extended version of the <a href="https://en.wikipedia.org/wiki/Observer_pattern">Observer pattern</a>. Think of push notifications to your phone as opposed
to reading data by opening your browser and asking for an update. The goal is to build event driven
asynchronous reactive systems.
</p>
</div>
</div>

<div id="outline-container-orgfbe7191" class="outline-2">
<h2 id="orgfbe7191">Creating Observables</h2>
<div class="outline-text-2" id="text-orgfbe7191">
<p>
There are a <a href="https://github.com/ReactiveX/RxJava/wiki/Creating-Observables">number of ways to create new Observables</a>. This post will only look at the two ways
that I've found to be the simpler ones. The first method well look at is <code>just</code>:
</p>

<div class="org-src-container">
<pre class="src src-Java">Observable.just(1);
</pre>
</div>

<p>
This creates an Observable that will emit the integer 1 and then complete.
</p>

<p>
To create an Observable that emits more than a single value you can use
<code>from</code>. From takes an iterable and creates an Observable that will emit
its values and then complete.
</p>

<div class="org-src-container">
<pre class="src src-Java">Observable.from(asList(1, 2, 3));
</pre>
</div>

<p>
Reactive extension, being asynchronous doesn't fully show it's power when
using such simple iterable items. For a more useful example think of a
scenario where you want to make three requests to another server and print
the resulting body to standard out. For now ignore the flatMap.
</p>
<div class="org-src-container">
<pre class="src src-Java">List&lt;String&gt; urlsToCheck = asList("example.com/1", "example.com/2", "example.com/3");

// #getData returns an Observable&lt;String&gt; with the pages body
Observable.from(urlsToCheck)
  .flatMap(url -&gt; getData(url))
</pre>
</div>

<p>
When you run this code no actual requests will be made. The Observable is
declared as a chain of operations to be performed when, and only when
the Observable is subscribed on. So in order to actually execute the
Observable and perform the requests we use subscribe.
</p>

<div class="org-src-container">
<pre class="src src-Java">Observable.from(urlsToCheck)
  .flatMap(url -&gt; getData(url))
  .subscribe(response -&gt; System.out.println(response));
// =&gt; body of example.com/1
// =&gt; body of example.com/3
// =&gt; body of example.com/2
</pre>
</div>

<p>
Running this code will actually execute the requests and print first the
body of <code>example.com/1</code>, then <code>example.com/3</code> and finally <code>example.com/2</code>.
Notice that because the request made to <code>example.com/3</code> was quicker than
<code>example.com/2</code>, <code>example.com/3</code>'s body was printed first.
</p>

<div class="org-src-container">
<pre class="src src-Java">Observable.from(urlsToCheck)
  .flatMap(url -&gt; getData(url))
  .subscribe(response -&gt; System.out.println(response));

System.out.println("Will this print before or after?");

// =&gt; Will this print before of after?
// =&gt; body of example.com/1
// =&gt; body of example.com/3
// =&gt; body of example.com/2
</pre>
</div>

<p>
The Observable will not block the execution of the program but continue to
run while the requests are made. So given that the request actually takes
some time to perform the text <code>Will this print before or after?</code> will be
printed before the bodies of the requests. In order to block and print,
something very useful when testing, we can use <code>toBlocking</code>. This will block
until the Observable completes resulting in the block below.
</p>

<div class="org-src-container">
<pre class="src src-Java">Observable.from(urlsToCheck)
  .flatMap(url -&gt; getData(url))
  .subscribe(response -&gt; System.out.println(response))
  .toBlocking()

System.out.println("Will this print before or after?");

// =&gt; body of example.com/1
// =&gt; body of example.com/3
// =&gt; body of example.com/2
// =&gt; Will this print before of after?
</pre>
</div>
</div>
</div>

<div id="outline-container-orgefa87ef" class="outline-2">
<h2 id="orgefa87ef">Intro to marble diagrams</h2>
<div class="outline-text-2" id="text-orgefa87ef">
<p>
The chosen form to visualize Observables is the marble diagram. A form used extensively at the
Reactive extensions documentation page. Most of the diagrams are interactive and you can drag the
different Observable data points around and experiment (not a possibility with the screenshots at this
post).
Something very useful when learning about Observables.
</p>

<p>
The diagram below shows an Observable list of integers. The integers are received over time as represented by
the arrow. The Observable receives first 1, followed by 2, and finally, after  a small amount of time as is
represented by the gap between the values, a 3.
<img src="http:/images/marble-observable.png" alt="marble-observable.png" />
</p>
<div class="org-src-container">
<pre class="src src-Java">Observable.from(asList(1, 2, 3);
</pre>
</div>

<p>
The next level of the diagram shows an operation being performed on the Observable. In this case the map operation.
Map takes each value emitted by the Observable and multiplies it by ten.
</p>


<div class="figure">
<p><img src="http:/images/marble-observable-operation.png" alt="marble-observable-operation.png" />
</p>
</div>
<div class="org-src-container">
<pre class="src src-Java">Observable.from(asList(1, 2, 3);
  .map(x -&gt; 10 * x);
</pre>
</div>

<p>
The final level shows us the result of the operation, once again the arrow represents time. Giving us first 10,
followed by 20 and after a slight delay the last number 30.
</p>


<div class="figure">
<p><img src="http:/images/marble-map.png" alt="marble-map.png" />
</p>
</div>
<div class="org-src-container">
<pre class="src src-Java">Observable.from(asList(1, 2, 3);
  .map(x -&gt; 10 * x)
  .subscribe(n -&gt; System.out.printLn(n));
  // 10
  // 20
  // 30
</pre>
</div>
</div>
</div>

<div id="outline-container-org0000b28" class="outline-2">
<h2 id="org0000b28">Some basic operators</h2>
<div class="outline-text-2" id="text-org0000b28">
</div>
<div id="outline-container-orgf6f893b" class="outline-3">
<h3 id="orgf6f893b">FlatMap</h3>
<div class="outline-text-3" id="text-orgf6f893b">
<p>
The first operator we'll look at is flatMap. As the name hints flatMap is similar to map. The difference
is that flatMap is intended to operate on Observables that in turn return new observables. Take the initial
example I showed you in the Creating Observables section where we made a number of requests and printed
their body to standard out. Had we not used flatMap but instead used map the requests would
never have been sent and  we would only get an Observable of
Observables that never would have been executed unless we subscribed to each one separately. If we however keep
pushing our Observables to the top they will continue to be executed. To do this we need to flatten our Observable
of Observables into a non nested Observable.
To illustrate the idea take the pseudo code below showing us how flatMap could potentially operate on an Array
structure. Mapping over a's nested arrays, performing the operation and finally flattening the result.
</p>

<div class="org-src-container">
<pre class="src src-Java">a = [ [ 1, 2 ], [ 3, 4 ] ]
b = a.flatmap(x -&gt; x + 1)

// b would equal
// [ 2, 3, 4, 5]
</pre>
</div>

<p>
FlatMap as applied on an Observable operates in a very similar way. Operating on each Observable, taking that
result, which in turn is an Observable and flattening it into one big Observable.
Once again notice that flatMap doesn't respect the order in which we have declared our data but instead will
operate on each value as we receive them as I described previously.
Below is an example of creating an Observable with the values 1, 2 and 3. "Flat mapping" over them in an operation that
returns an Observable with the incremented number using <code>just</code>.
</p>


<div class="figure">
<p><img src="http:/images/marble-flatmap.png" alt="marble-flatmap.png" />
</p>
</div>
<div class="org-src-container">
<pre class="src src-Java">Observable.from(asList(1, 2 ,3))
  .flatMap(n -&gt; just(n + 1)
  .subscribe(r -&gt; System.out.println(r));
  // =&gt; 2
  // =&gt; 4
  // =&gt; 3
</pre>
</div>
</div>
</div>

<div id="outline-container-org87cd74e" class="outline-3">
<h3 id="org87cd74e">ConcatMap</h3>
<div class="outline-text-3" id="text-org87cd74e">
<p>
<code>concatMap</code> is, as you can see from the marble diagram very similar to <code>flatMap</code> with one subtle difference.
<code>concatMap</code> respects the order in which we declare our data.
So even if our second HTTP request takes longer to perform than the third one. We will still get them in the
order we specified in our initial list. Otherwise we still map over our values. Perform the operation that for
each request returns a new Observable and finally we concatenate the Observable of Observables into a single
Observable in the same order as we sent the requests.
</p>


<div class="figure">
<p><img src="http:/images/marble-concatmap.png" alt="marble-concatmap.png" />
</p>
</div>
<div class="org-src-container">
<pre class="src src-Java">Observable.from(asList(1, 2 ,3))
  .concatMap(n -&gt; getHTTPResponse(n))
  .subscribe(r -&gt; System.out.println(r));
  // 2
  // 3
  // 3

</pre>
</div>
</div>
</div>

<div id="outline-container-org327645d" class="outline-3">
<h3 id="org327645d">Reduce</h3>
<div class="outline-text-3" id="text-org327645d">
<p>
This operator takes an Observable and calls the operator with two arguments. First the previously returned value
or the default value of the datatype returned by the operator and secondly the currently emitted value.
Below I demonstrate reduce by calculation the sum of an Observable of integers.
First call sum will be 0, an integers default value, and n will be 1. The next call sum will be the previously
returned value of one and n will be 2. The last call sum will be 3 and n will be 3 finally returning 6.
</p>


<div class="figure">
<p><img src="http:/images/marble-reduce.png" alt="marble-reduce.png" />
</p>
</div>

<div class="org-src-container">
<pre class="src src-Java">Observable.from(asList(1, 2 ,3))
  .reduce((sum, n) -&gt; sum + n)
  .subscribe(r -&gt; System.out.println(r));
  // 6
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgc33395f" class="outline-2">
<h2 id="orgc33395f">Combining Observables</h2>
<div class="outline-text-2" id="text-orgc33395f">
<p>
To keep evaluating and performing our observables we need to keep pushing the Observables
to the top of our chain. Sometimes we end up with two or more sequences that need to be
executed. So let's look at some of the basic ways of <a href="https://github.com/ReactiveX/RxJava/wiki/Creating-Observables">combining Observables</a>.
</p>
</div>

<div id="outline-container-org0add57f" class="outline-3">
<h3 id="org0add57f">Merge</h3>
<div class="outline-text-3" id="text-org0add57f">
<p>
    Merges two Observable sequences. The values will be emitted as they are received ignoring the order
that they are declared in.
</p>


<div class="figure">
<p><img src="http:/images/marble-merge.png" alt="marble-merge.png" />
</p>
</div>
<div class="org-src-container">
<pre class="src src-Java">Observable&lt;String&gt; as = Observable.from(asList("q", "w" ,"e"));
Observable&lt;String&gt; bs = Observable.from(asList("1", "2", "3"));

Observable.merge(as, bs)
  .map(s -&gt; String.format("value: %s", s))
  .subscribe(r -&gt; System.out.println(r));
// =&gt; value: q
// =&gt; value: 1
// =&gt; value: 2
// =&gt; value: w
// =&gt; value: e
// =&gt; value: 3
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf91fce1" class="outline-3">
<h3 id="orgf91fce1">Zip</h3>
<div class="outline-text-3" id="text-orgf91fce1">
<p>
    Zip takes a number of  Observable sequences, collects the first value emitted by each sequence
and calls the operator with values "zipped" together. Will complete as soon as one of the sequences
is completed.
</p>


<div class="figure">
<p><img src="http:/images/marble-zip.png" alt="marble-zip.png" />
</p>
</div>
<div class="org-src-container">
<pre class="src src-Java">Observable&lt;String&gt; as = Observable.from(asList("q", "w" ,"e"));
Observable&lt;Integer&gt; bs = Observable.from(asList(1, 2, 3));

Observable.zip(
  as,
  bs,
  (a, b) -&gt; String.format("a: %s, b: %d ", a, b)
)
  .subscribe(r -&gt; System.out.println(r));
// a: q, b: 1
// a: w, b: 2
// a: e, b: 3
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orga2fe676" class="outline-2">
<h2 id="orga2fe676">Final thoughts</h2>
<div class="outline-text-2" id="text-orga2fe676">
<p>
And so we reach the end of this quick intro to Observables.
Hopefully it's enough to get you started. A good resource to learn more is the <a href="http://reactivex.io/">Reactive extensions</a> website.
Otherwise the best way to learn I've found is just to pull your sleeves up, get your hands dirty and
start writing some code.
Have any thoughts or other feedback? Find me on twitter.
</p>
</div>
</div>
<div id="icons"><ul><li><a href="https://github.com/rpkarlsson"><img alt="My Github" src="/images/GitHub-Mark-32px.png" /></a></li><li><a href="https://twitter.com/ropkn"><img alt="My Twitter" src="/images/TwitterLogo.png" /></a></li></ul></div><script src="/js/main.js"></script></div></body></html>